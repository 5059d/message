


#-*- encoding: utf-8 -*-  
import sys  
import locale  
import poplib  
from email import parser  
import email  
import string  
  
# 确定运行环境的encoding  
__g_codeset = sys.getdefaultencoding()  
if "ascii"==__g_codeset:  
    __g_codeset = locale.getdefaultlocale()[1]  
#  
  
def object2double(obj):  
    if(obj==None or obj==""):  
        return 0  
    else:  
        return float(obj)  
    #end if      
#  
  
def utf8_to_mbs(s):  
    return s.decode("utf-8").encode(__g_codeset)  
#  
  
def mbs_to_utf8(s):  
    return s.decode(__g_codeset).encode("utf-8")  
#  
  
host = 'pop.exmail.qq.com'  
username = 'user1@xxxx.cn'  
password = 'password'  
  
pop_conn = poplib.POP3_SSL(host)  
pop_conn.user(username)  
pop_conn.pass_(password)  
  
#Get messages from server:  
# 获得邮件  
messages = [pop_conn.retr(i) for i in range(1, len(pop_conn.list()[1]) + 1)]  
#print messages  
  
#print "--------------------------------------------------"  
# Concat message pieces:  
messages = ["\n".join(mssg[1]) for mssg in messages]  
#print messages  
  
#Parse message intom an email object:  
# 分析  
messages = [parser.Parser().parsestr(mssg) for mssg in messages]  
i = 0  
for index in range(0,len(messages)):  
    message = messages[index];  
    i = i + 1;  
    subject = message.get('subject')     
    h = email.Header.Header(subject)  
    dh = email.Header.decode_header(h)  
    subject = unicode(dh[0][0], dh[0][1]).encode('utf8')  
    mailName = "mail%d.%s" % (i, subject)  
    f = open('%d.log'%(i), 'w');  
    print >> f, "Date: ", message["Date"]  
    print >> f, "From: ", email.utils.parseaddr(message.get('from'))[1]  
    print >> f, "To: ", email.utils.parseaddr(message.get('to'))[1]  
    print >> f, "Subject: ", subject  
    print >> f, "Data: "  
    j = 0  
    for part in message.walk():  
        j = j + 1  
        fileName = part.get_filename()  
        contentType = part.get_content_type()  
        mycode=part.get_content_charset();  
        # 保存附件  
        if fileName:  
            data = part.get_payload(decode=True)  
            h = email.Header.Header(fileName)  
            dh = email.Header.decode_header(h)  
            fname = dh[0][0]  
            encodeStr = dh[0][1]  
            if encodeStr != None:  
                fname = fname.decode(encodeStr, mycode)  
            #end if  
            fEx = open("%s"%(fname), 'wb')  
            fEx.write(data)  
            fEx.close()  
        elif contentType == 'text/plain':# or contentType == 'text/html':  
            #保存正文  
            data = part.get_payload(decode=True)  
            content=str(data);  
            if mycode=='gb2312':  
                content= mbs_to_utf8(content)  
            #end if      
            nPos = content.find('降息')  
            print("nPos is %d"%(nPos))  
            print >> f, data  
        #end if  
    #end for   
    f.close()  
#end for      
pop_conn.quit()  





#!/usr/bin/env python  
# -*- coding: gbk -*-  
#导入smtplib和MIMEText  
import smtplib  
from email.mime.text import MIMEText  
#############  
#要发给谁，这里发给2个人  
mailto_list=["aaa@qq.com","123456789@qq.com"]  
#####################  
#设置服务器，用户名、口令以及邮箱的后缀  
mail_host="smtp.qq.com"  
mail_user="your qq"  
mail_pass="password"  
mail_postfix="qq.com"  
######################  
def send_mail(to_list,sub,content):  
    ''''' 
    to_list:发给谁 
    sub:主题 
    content:内容 
    send_mail("aaa@126.com","sub","content") 
    '''  
    me=mail_user+"<"+mail_user+"@"+mail_postfix+">"  
    msg = MIMEText(content)  
    msg['Subject'] = sub #设置主题  
    msg['From'] = me     #发件人  
    msg['To'] = ";".join(to_list) #收件人  
    try:  
        s = smtplib.SMTP()  
        s.connect(mail_host)  
        s.login(mail_user,mail_pass)  
        s.sendmail(me, to_list, msg.as_string())  
        s.close()  
        return True  
    except Exception, e:  
        print str(e)  
        return False  
if __name__ == '__main__':  
    if send_mail(mailto_list,"subject","content"):  
        print "发送成功"  
    else:  
        print "发送失败"  



接收邮件 根据发件人并提取出指定邮件
[python] view plain copy
import poplib  
import string  
from email import parser  
  
host = 'pop.qq.com'  
username = 'your_qq@qq.com'  
password = 'your_password'  
  
pop_conn = poplib.POP3_SSL(host)  
pop_conn.user(username)  
pop_conn.pass_(password)  
  
#从服务器获取邮件列表:  
messages = [pop_conn.retr(i) for i in range(1, len(pop_conn.list()[1]) + 1)]  
  
# Concat message pieces:  
messages = ["/n".join(mssg[1]) for mssg in messages]  
  
#解析邮件到email object:  
messages = [parser.Parser().parsestr(mssg) for mssg in messages]  
for message in messages:  
    addrfrom = str(message.get('from'))  
    try:  
        addrfrom.index('info@kingsoft.com')  
        start_addr = addrfrom.index('<')  
        end_addr = addrfrom.index('>')  
        print addrfrom[start_addr + 1 : end_addr] #如果邮件是来自金山则打印他的标题  
    except ValueError:  
        continue  
pop_conn.quit()  


要使用imap接收邮件,当然要导入imaplib拉.
import imaplib
然后按常规的,建立链接→登录
conn = imaplib.IMAP4("imap.xxx.com",143)

conn.login("userName","password")
然后我想查看收件箱的邮件,咋办呢?要先选择一个目录,收件箱默认名称是"INBOX",IMAP是支持创建文件夹,查看其它文件夹的,如果是自己 新建的文件夹,那么名称一般会是"INBOX.新建文件夹",不同的邮箱可能表示方式不一样,如果你不知道的话,那运行conn.list()查看所有的 文件夹.
conn.select("INBOX")
选择后,然后查看文件夹,注意,IMAP的查看其实是一个搜索的过程,IMAP的原始命令是search all(大概的),在python里这么用:
type, data = conn.search(None, 'ALL')
然后返回的是这个收件箱里所有邮件的编号,按接收时间升序排列,最后的表示最近.
search这个很鬼麻烦,因为官方文档里没讲这个函数的第二个参数怎么用,于是找了下,可以填的命令有:
http://www.afterlogic.com/mailbee-net/docs/MailBee.ImapMail.Imap.Search_overload_1.html
于是如果我想找Essh邮件的话,使用
type, data = conn.search(None, '(SUBJECT "Essh")')
里面要用一个括号,代表是一个查询条件,可以同时指定多个查询条件,例如FROM xxxx SUBJECT "aaa",注意,命令要用括号罩住(痛苦的尝试)
search第一个参数是charset的意思,填None表示用默认ASCII,
data里获取到的是一个只有一个字符串元素的数组,包含很多数字,用空格隔开
['1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103'
于是想获取最后一封的做法是:
msgList = data[0].split()
last = msgList[len(msgList) - 1]
然后把那个邮件获取回来,用fetch函数
例子:
conn.fetch(last, '(RFC822.SIZE BODY[HEADER.FIELDS (SUBJECT)])')
但是返回的是一串MIME编码的东东,看不懂,如果能像eml那一操作一封邮件就好了.
方法是有的,用email库.
import email
然后以RFC822获取邮件格式,再用email.message_from_string转换为message对象.就可以当message操作了,(http://docs.python.org/2/library/email.message.html)
type,data=connect.fetch(msgList[len(msgList)-1],'(RFC822)')
msg=email.message_from_string(data[0][1])
content=msg.get_payload(decode=True)
最后content得到就是邮件的内容了,这样暂时达到我的目的了,说到这里先.

1、Imaplib
IMAP4.append(mailbox, flags, date_time, message)：Append message to named mailbox.
IMAP4.authenticate(mechanism, authobject)：Authenticate command — requires response processing.mechanism specifies which authentication mechanism is to be used - it should appear in the instance variable capabilities in the form AUTH=mechanism.
IMAP4.check()：Checkpoint mailbox on server.
IMAP4.close()：Close currently selected mailbox. Deleted messages are removed from writable mailbox. This is the recommended command before LOGOUT.
IMAP4.copy(message_set, new_mailbox)：Copy message_set messages onto end of new_mailbox.
IMAP4.create(mailbox)：Create new mailbox named mailbox.
IMAP4.delete(mailbox)：Delete old mailbox named mailbox.
IMAP4.deleteacl(mailbox, who)：Delete the ACLs (remove any rights) set for who on mailbox.
IMAP4.expunge()：Permanently remove deleted items from selected mailbox. Generates an EXPUNGE response for each deleted message. Returned data contains a list of EXPUNGE message numbers in order received.
IMAP4.fetch(message_set, message_parts)：Fetch (parts of) messages. message_parts should be a string of message part names enclosed within parentheses, eg: "(UID BODY[TEXT])". Returned data are tuples of message part envelope and data.
IMAP4.getacl(mailbox)：Get the ACLs for mailbox. The method is non-standard, but is supported by the Cyrus server.
IMAP4.getannotation(mailbox, entry, attribute)：Retrieve the specified ANNOTATIONs for mailbox. The method is non-standard, but is supported by the Cyrus server.
IMAP4.getquota(root)：Get the quota root‘s resource usage and limits. This method is part of the IMAP4 QUOTA extension defined in rfc2087.
IMAP4.getquotaroot(mailbox)：Get the list of quota roots for the named mailbox. This method is part of the IMAP4 QUOTA extension defined in rfc2087.
IMAP4.list([directory[, pattern]])：List mailbox names in directory matching pattern. directory defaults to the top-level mail folder, and pattern defaults to match anything. Returned data contains a list of LIST responses.
IMAP4.login(user, password)：Identify the client using a plaintext password. The password will be quoted.
IMAP4.login_cram_md5(user, password)：Force use of CRAM-MD5 authentication when identifying the client to protect the password. Will only work if the server CAPABILITY response includes the phrase AUTH=CRAM-MD5.
IMAP4.logout()：Shutdown connection to server. Returns server BYE response.
IMAP4.lsub([directory[, pattern]])：List subscribed mailbox names in directory matching pattern. directory defaults to the top level directory and pattern defaults to match any mailbox. Returned data are tuples of message part envelope and data.
IMAP4.myrights(mailbox)：Show my ACLs for a mailbox (i.e. the rights that I have on mailbox).
IMAP4.namespace()：Returns IMAP namespaces as defined in RFC2342.
IMAP4.noop()：Send NOOP to server.
IMAP4.open(host, port)：Opens socket to port at host. This method is implicitly called by the IMAP4 constructor. The connection objects established by this method will be used in the read, readline, send, and shutdown methods. You may override this method.
IMAP4.partial(message_num, message_part, start, length)：Fetch truncated part of a message. Returned data is a tuple of message part envelope and data.
IMAP4.proxyauth(user)：Assume authentication as user. Allows an authorised administrator to proxy into any user’s mailbox.
IMAP4.read(size)：Reads size bytes from the remote server. You may override this method.
IMAP4.readline()：Reads one line from the remote server. You may override this method.
IMAP4.recent()：Prompt server for an update. Returned data is None if no new messages, else value of RECENT response.
IMAP4.rename(oldmailbox, newmailbox)：Rename mailbox named oldmailbox to newmailbox.
IMAP4.response(code)：Return data for response code if received, or None. Returns the given code, instead of the usual type.
IMAP4.search(charset, criterion[, ...])：Search mailbox for matching messages. charset may be None, in which case no CHARSET will be specified in the request to the server. The IMAP protocol requires that at least one criterion be specified; an exception will be raised when the server returns an error.
IMAP4.send(data)：Sends data to the remote server. You may override this method.
IMAP4.setacl(mailbox, who, what)：Set an ACL for mailbox. The method is non-standard, but is supported by the Cyrus server.
IMAP4.setannotation(mailbox, entry, attribute[, ...])：Set ANNOTATIONs for mailbox. The method is non-standard, but is supported by the Cyrus server.
IMAP4.setquota(root, limits)：Set the quota root‘s resource limits. This method is part of the IMAP4 QUOTA extension defined in rfc2087.
IMAP4.shutdown()：Close connection established in open. This method is implicitly called by IMAP4.logout(). You may override this method.
IMAP4.socket()：Returns socket instance used to connect to server.
IMAP4.sort(sort_criteria, charset, search_criterion[, ...])：The sort command is a variant of search with sorting semantics for the results. Returned data contains a space separated list of matching message numbers.
IMAP4.status(mailbox, names)：Request named status conditions for mailbox.
IMAP4.store(message_set, command, flag_list)：Alters flag dispositions for messages in mailbox. command is specified by section 6.4.6 of RFC 2060 as being one of “FLAGS”, “+FLAGS”, or “-FLAGS”, optionally with a suffix of ”.SILENT”.
IMAP4.thread(threading_algorithm, charset, search_criterion[, ...])：The thread command is a variant of search with threading semantics for the results. Returned data contains a space separated list of thread members.
IMAP4.uid(command, arg[, ...])：Execute command args with messages identified by UID, rather than message number. Returns response appropriate to command. At least one argument must be supplied; if none are provided, the server will return an error and an exception will be raised.
IMAP4.unsubscribe(mailbox)：Unsubscribe from old mailbox.
IMAP4.xatom(name[, arg[, ...]])：Allow simple extension commands notified by server in CAPABILITY response.
IMAP4_SSL.ssl()：Returns SSLObject instance used for the secure connection with the server.
IMAP4.PROTOCOL_VERSION：The most recent supported protocol in the CAPABILITY response from the server.
IMAP4.debug：Integer value to control debugging output. The initialize value is taken from the module variable Debug. Values greater than three trace each command.
2、imap 命令详解
CREATE <folder>：CREATE可以创建指定名字的新邮箱。邮箱名称通常是带路径的文件夹全名。（有些IMAP客户机使用邮件夹称呼新邮箱）
C: A003 CREATE owatagusiam/                 /*创建一个新目录owatagusiam*/
S: A003 OK CREATE completed
C: A004 CREATE owatagusiam/blurdybloop  
/* 在创建的目录owatagusiam下创建一个名为blurdybloop 的邮箱，当然可以省略第一步，直接A004 CREATE owatagusiam/blurdybloop ，表示在新的目录owatagusiam 下创建了一个名为blurdybloop 的邮箱*/         
S: A004 OK CREATE completed
DELETE <folder>：DELETE命令删除指定名字的文件夹。文件夹名字通常是带路径的文件夹全名，当邮箱被删除后，其中的邮件也不复存在。
C: A683 DELETE blurdybloop
S: A683 OK DELETE completed 
C: A684 DELETE foo
S: A684 NO Name "foo" has inferior hierarchical names
C: A685 DELETE foo/bar 
S: A685 OK DELETE Completed
RENAME <old folder><new folder>：RENAME命令可以修改文件夹的名称，它使用两个参数：当前邮箱名和新邮箱名，两个参数的命名符合标准路径命名规则。
C: A683 RENAME blurdybloop sarasoop
S: A683 OK RENAME completed
C: A684 RENAME stuff/junk newbox         /*把stuff目录（文件夹）下的邮箱junk改名为newbox*/
S: A684 OK RENAME Completed
LIST <BASE><template>：LIST命令用于列出邮箱中已有的文件夹，有点像操作系统的列目录命令，有两个参数，邮箱路 径参数BASE：表示用户登陆目录；第二个参数template：表示希望显示的邮箱名。这个命令可以包含起始的路径位置和需要列出的文件夹所符合的特 征，可以使用通配符"*"。
C: A101 LIST "" ""
S: * LIST (\Noselect) "/" ""
S: A101 OK LIST Completed
C: A102 LIST #news.comp.mail.misc ""
S: * LIST (\Noselect) "." #news.
S: A102 OK LIST Completed
C: A103 LIST /usr/staff/jones ""
S: * LIST (\Noselect) "/" /
S: A103 OK LIST Completed
C: A202 LIST ~/Mail/ %
S: * LIST (\Noselect) "/" ~/Mail/foo
S: * LIST () "/" ~/Mail/meetings
S: A202 OK LIST completed
APPEND <folder><attributes><date/time><size><mail data>：APPEND命令允许Client上载一个邮件到指定的Folder（文件夹/邮箱）中。命令中包含了新邮件的属性、日期/时间、大 小，随后是邮件数据。
C: A003 APPEND saved-messages (\Seen) {310}
C: Date: Mon， 7 Feb 1994 21:52:25 -0800 (PST)
C: From: Fred Foobar <foobar@Blurdybloop.COM>
C: Subject: afternoon meeting
C: To: mooch@owatagu.siam.edu
C: Message-Id: <B27397-0100000@Blurdybloop.COM>
C: MIME-Version: 1.0
C: Content-Type: TEXT/PLAIN; CHARSET=US-ASCII
C:
C: Hello Joe， do you think we can meet at 3:30 tomorrow?
C:
S: A003 OK APPEND completed
SELECT <folder>：SELECT命令让Client选定某个邮箱（Folder），表示即将对该邮箱（Folder）内的邮件作操作。邮箱标志的当前状态也返回给了用户，同时返回的还有一些关于邮件和邮箱的附加信息。
C: A142 SELECT INBOX
S: * 172 EXISTS
S: * 1 RECENT
S: * OK [UNSEEN 12] Message 12 is first unseen
S: * OK [UIDVALIDITY 3857529045] UIDs valid
S: * FLAGS (\Answered \Flagged \Deleted \Seen \Draft)
S: * OK [PERMANENTFLAGS (\Deleted \Seen \*)] Limited
S: A142 OK [READ-WRITE] SELECT completed
FETCH <mail id><datanames>：FETCH 命令用于读取邮件的文本信息，且仅用于显示的目的。包含两个参数，messageset：表示希望读取的邮件号列表，IAMP服务器邮箱中的每个邮件都有 一个唯一的ID标识，（邮件号列表参数可以是一个邮件号，也可以是由逗号分隔的多个邮件号，或者由冒号间隔的一个范围），IMAP服务器返回邮件号列表中 全部邮件的指定数据项内容。
数据名参数确定能够被独立返回的邮件的一部分，下面我们看看各参数返回的邮件信息：
ALL：只返回按照一定格式的邮件摘要，包括邮件标志、RFC822.SIZE、自身的时间和信封信息。IMAP客户机能够将标准邮件解析成这些信息并显示出来。
BODY：只返回邮件体文本格式和大小的摘要信息。IMAP客户机可以识别这些细腻，并向用户显示详细的关于邮件的信息。其实是一些非扩展的BODYSTRUCTURE的信息。
FAST：只返回邮件的一些摘要，包括邮件标志、RFC822.SIZE、和自身的时间。
FULL：同样的还是一些摘要信息，包括邮件标志、RFC822.SIZE、自身的时间和BODYSTRUCTURE的信息。
BODYSTRUCTUR： 是邮件的[MIME-IMB]的体结构。这是服务器通过解析[RFC-2822]头中的[MIME-IMB]各字段和[MIME-IMB]头信息得出来 的。包括的内容有：邮件正文的类型、字符集、编码方式等和各附件的类型、字符集、编码方式、文件名称等等。
ENVELOPE：信息的信封结构。是服务器通过解析[RFC-2822]头中的[MIME-IMB]各字段得出来的，默认各字段都是需要的。主要包括：自身的时间、附件数、收件人、发件人等。
FLAGS：此邮件的标志。
INTERNALDATE：自身的时间。
RFC822.SIZE：邮件的[RFC-2822]大小
RFC822.HEADER：在功能上等同于BODY.PEEK[HEADER]，
RFC822：功能上等同于BODY[]。
RFC822.TEXT：功能上等同于BODY[TEXT]
UID：返回邮件的UID号，UID号是唯一标识邮件的一个号码。
BODY[section] <<partial>>：返回邮件的中的某一指定部分，返回的部分用section来表示，section部分包含的信息通常是 代表某一部分的一个数字或者是下面的某一个部分：HEADER, HEADER.FIELDS, HEADER.FIELDS.NOT, MIME, and TEXT。如果section部分是空的话，那就代表返回全部的信息，包括头信息。
BODY[HEADER]返回完整的文件头信息。
BODY[HEADER.FIELDS ()]：在小括号里面可以指定返回的特定字段。
BODY[HEADER.FIELDS.NOT ()]：在小括号里面可以指定不需要返回的特定字段。
BODY[MIME]：返回邮件的[MIME-IMB]的头信息，在正常情况下跟BODY[HEADER]没有区别。
BODY[TEXT]：返回整个邮件体，这里的邮件体并不包括邮件头。
STORE <mail id><new attributes>：STORE 命令用于修改指定邮件的属性，包括给邮件打上已读标记、删除标记，等等。STORE命令当前只有两个数据项类型可用，FLAGS：表示邮件的一组标志； FLAGS.SLIENT，表示一组邮件的标志，通过在两种数据项前加上加号或者减号可以进一步改变它们的执行情况，加号表示数据项的值添加到邮件中，减 号表示将数据项的值从邮件中删除。
C: A003 STORE 2:4 +FLAGS (\Deleted)      /*冒号表示间隔的一个范围：给从2到4的邮件设置Deleted属性*/
S: * 2 FETCH FLAGS (\Deleted \Seen)
S: * 3 FETCH FLAGS (\Deleted)
S: * 4 FETCH FLAGS (\Deleted \Flagged \Seen)
S: A003 OK STORE completed
同时改命令还可以用于把邮件标记为未读等等。在web上可以对邮件进行的操作在imap中都可以实现。
CLOSE：CLOSE命令表示Client结束对当前Folder（文件夹/邮箱）的访问，关闭邮箱该邮箱中所有标志为、DELETED的邮件就被从物理上删除。CLOSE没有命令参数。随后可以SELECT另一Folder。
C: A341 CLOSE
S: A341 OK CLOSE completed

EXPUNGE:EXPUNGE命令在不关闭邮箱的情况下删除所有的标志为、DELETED的邮件。EXPUNGE删除的邮件将不可以恢复。 
C: A202 EXPUNGE
S: * 3 EXPUNGE
S: * 3 EXPUNGE
S: * 5 EXPUNGE
S: * 8 EXPUNGE
S: A202 OK EXPUNGE completed
LOGOUT:LOGOUT命令结束本次IMAP会话。
C: A023 LOGOUT
S: * BYE IMAP4rev1 Server logging out
S: A023 OK LOGOUT completed
(Server and client then close the connection)
EXAMINE <mailbox>:
EXAMINE命令以只读方式打开邮箱，参数是需要打开的邮箱的名字，使用EXAMINE命令打开的邮箱不允许对邮件进行改动，因此不能增加或删除邮件的标志。
SUBSCRIBE <mailbox>:SUBSCRIBE命令用来在客户机的活动邮箱列表中增加一个邮箱，该命令只有一个参数，希望添加的邮箱名。
C: A114 SUBSCRIBE new/anotherbox
S: A114 OK SUBSCRIBE completed
UNSUBSCRIBE <mailbox>:UNSUBSCRIBE命令用来从活动列表中去掉一个邮箱，一个参数：希望去掉的邮箱名。
C: A115 UNSUBSCRIBE new/anotherbox
S: A115 OK SUBSCRIBE completed
LSUB <folder><mailbox>:LSUB命令修正了LIST命令，LIST返回用户$HOME目录下所有的文件，但LSUB命令只显示那些使用SUBSCRIBE命令设置为活动邮箱的文件。两个参数：邮箱路径和邮箱名。
C: A116 LSUB “” *
S:* LSUB () “/” stuff/junk
S:* LSUB () “/” neebox
S:* LSUB () “/” new/anotherbox
S: A116 OK LSUB completed
STATUS <mailbox>(<parameter1>  < parameter2>  ……<parameter5>):STATUS命令查询邮箱的当前状态。第一个参数是需要查询的邮箱名，第二个参数是客户机需要查询的项目列 表（要查询显示的信息），当在圆括号中。STATUS可以在不使用SELECT命令（打开邮箱）或者EXAMINE（以只读方式打开邮箱）前提下获取邮箱 的信息。
STATUS命令可以获得的数据项
项 目                 说  明
MESSAGE         邮箱中的邮件总数
RECENT         邮箱中标志为\RECENT的邮件数
UIDNEXT         可以分配给新邮件的下一个UID
UIDVALIDITY         邮箱的UID有效性标志
UNSEEN         邮箱中没有被标志为\UNSEEN的邮件数
C: A117 STATUS inbox  (message recent unseen)
S:* STATUS inbox (MESSAGE 1 RECENT 0 UNSENN 0)
S: A117 OK STATUS completed
C: A118 STATUS newbox  (message recent unseen)
S:* STATUS inbox (MESSAGE 1 RECENT 0 UNSENN 2)
S: A118 OK STATUS completed
CHECK :CHECK命令用来在邮箱设置一个检查点。没有参数。就是IMAP中的sync命令。任何未完成的操作，例如从服务器内存向硬盘写数据，都将会被做完以保持邮箱的一致性状态。该命令确保乃村中的磁盘缓冲数据都被写到了磁盘上。
SEARCH [CHARSET specification] (search criteria):命 令可以根据搜索条件在处于活动状态的邮箱中搜索邮件，然后显示匹配的邮件编号。字符集标志参数[CHARSET specification]由CHARSET和注册的字符集标志符组成，缺省的标志符是US-ASCⅡ，所以该参数长省略。search criteria：查询条件参数，明确查询的关键字和值。查询关键字有几十种。
C: A119 SEARCH header subject another
S: SEARCH 1 2
S:* A119 OK SEARCH completed
C: A120 SEARCH header subject another
S: *SEARCH 2
S: A120 OK SEARCH completed
C: A121 SEARCH UNSEEN
S: *SEARCH 1 2
S: A120 OK SEARCH completed
以上每个例子都在邮件头的Subject:字段中查询一个不同的单词。服务器返回条件的邮件号列表，如果没有匹配邮件则返回不带UID的SEARCH单词。
COPY <mail id><mailboxname>:COPY命令可以把邮件从一个邮箱复制到另一个邮箱，两个参数：mail id是希望从活动邮箱中复制的邮件的标号，mailboxname是希望邮件被复制到的邮箱。
IAMP没有定义移动邮件的命令，移动操作相当于先把邮件复制到新邮箱中，然后对源邮箱中的邮件设置\DELETED标志。下一次执行检查点过后，新邮箱中的邮件被删除，新邮件就被显示出来。
UID:UID 命令和FETCH、COPY、STORE命令或者SEARCH命令一起使用，它允许这些命令使用邮件的UID号而不是在邮箱中的顺序号。UID号是唯一标 识邮件系统中邮件的32位证书。通常这些命令都使用顺序号来标识邮箱中的邮件，使用UID可以使IMAP客户机记住不同IMAP会话中的邮件。
CAPABILITY:CAPABILITY命令请求返回IMAP服务器支持的功能列表，服务器收到客户机发送的CAPABILITY命令后将返回该服务器所支持的功能。无参数。
C: A122 CAPABILITY
S:*A122 CAPABILITY IMAP4 IMAP4REVl NAMESPACE IDLE SCAN SORT   MAILBOX
--REFERRALS [ic:ccc] LOGIN-REFERRALS AUTH=LOGIN THREAD=
ORDERDSUBJECT
S: A122 OK CAPABILITY completed
NOOP:NOOP命令什么也不做，用来向服务器发送自动命令，防止因长时间处于不活动状态而导致连接中断，服务器对该命令的响应始终为肯定。无参数。
LOGOUT:LOGOUT命令使当前登陆用户退出登陆并关闭所有打开的邮箱，任何做了\DELETED标志的邮件都将在这个时候被删除。1、Imaplib
IMAP4.append(mailbox, flags, date_time, message)：Append message to named mailbox.
IMAP4.authenticate(mechanism, authobject)：Authenticate command — requires response processing.mechanism specifies which authentication mechanism is to be used - it should appear in the instance variable capabilities in the form AUTH=mechanism.
IMAP4.check()：Checkpoint mailbox on server.
IMAP4.close()：Close currently selected mailbox. Deleted messages are removed from writable mailbox. This is the recommended command before LOGOUT.
IMAP4.copy(message_set, new_mailbox)：Copy message_set messages onto end of new_mailbox.
IMAP4.create(mailbox)：Create new mailbox named mailbox.
IMAP4.delete(mailbox)：Delete old mailbox named mailbox.
IMAP4.deleteacl(mailbox, who)：Delete the ACLs (remove any rights) set for who on mailbox.
IMAP4.expunge()：Permanently remove deleted items from selected mailbox. Generates an EXPUNGE response for each deleted message. Returned data contains a list of EXPUNGE message numbers in order received.
IMAP4.fetch(message_set, message_parts)：Fetch (parts of) messages. message_parts should be a string of message part names enclosed within parentheses, eg: "(UID BODY[TEXT])". Returned data are tuples of message part envelope and data.
IMAP4.getacl(mailbox)：Get the ACLs for mailbox. The method is non-standard, but is supported by the Cyrus server.
IMAP4.getannotation(mailbox, entry, attribute)：Retrieve the specified ANNOTATIONs for mailbox. The method is non-standard, but is supported by the Cyrus server.
IMAP4.getquota(root)：Get the quota root‘s resource usage and limits. This method is part of the IMAP4 QUOTA extension defined in rfc2087.
IMAP4.getquotaroot(mailbox)：Get the list of quota roots for the named mailbox. This method is part of the IMAP4 QUOTA extension defined in rfc2087.
IMAP4.list([directory[, pattern]])：List mailbox names in directory matching pattern. directory defaults to the top-level mail folder, and pattern defaults to match anything. Returned data contains a list of LIST responses.
IMAP4.login(user, password)：Identify the client using a plaintext password. The password will be quoted.
IMAP4.login_cram_md5(user, password)：Force use of CRAM-MD5 authentication when identifying the client to protect the password. Will only work if the server CAPABILITY response includes the phrase AUTH=CRAM-MD5.
IMAP4.logout()：Shutdown connection to server. Returns server BYE response.
IMAP4.lsub([directory[, pattern]])：List subscribed mailbox names in directory matching pattern. directory defaults to the top level directory and pattern defaults to match any mailbox. Returned data are tuples of message part envelope and data.
IMAP4.myrights(mailbox)：Show my ACLs for a mailbox (i.e. the rights that I have on mailbox).
IMAP4.namespace()：Returns IMAP namespaces as defined in RFC2342.
IMAP4.noop()：Send NOOP to server.
IMAP4.open(host, port)：Opens socket to port at host. This method is implicitly called by the IMAP4 constructor. The connection objects established by this method will be used in the read, readline, send, and shutdown methods. You may override this method.
IMAP4.partial(message_num, message_part, start, length)：Fetch truncated part of a message. Returned data is a tuple of message part envelope and data.
IMAP4.proxyauth(user)：Assume authentication as user. Allows an authorised administrator to proxy into any user’s mailbox.
IMAP4.read(size)：Reads size bytes from the remote server. You may override this method.
IMAP4.readline()：Reads one line from the remote server. You may override this method.
IMAP4.recent()：Prompt server for an update. Returned data is None if no new messages, else value of RECENT response.
IMAP4.rename(oldmailbox, newmailbox)：Rename mailbox named oldmailbox to newmailbox.
IMAP4.response(code)：Return data for response code if received, or None. Returns the given code, instead of the usual type.
IMAP4.search(charset, criterion[, ...])：Search mailbox for matching messages. charset may be None, in which case no CHARSET will be specified in the request to the server. The IMAP protocol requires that at least one criterion be specified; an exception will be raised when the server returns an error.
IMAP4.send(data)：Sends data to the remote server. You may override this method.
IMAP4.setacl(mailbox, who, what)：Set an ACL for mailbox. The method is non-standard, but is supported by the Cyrus server.
IMAP4.setannotation(mailbox, entry, attribute[, ...])：Set ANNOTATIONs for mailbox. The method is non-standard, but is supported by the Cyrus server.
IMAP4.setquota(root, limits)：Set the quota root‘s resource limits. This method is part of the IMAP4 QUOTA extension defined in rfc2087.
IMAP4.shutdown()：Close connection established in open. This method is implicitly called by IMAP4.logout(). You may override this method.
IMAP4.socket()：Returns socket instance used to connect to server.
IMAP4.sort(sort_criteria, charset, search_criterion[, ...])：The sort command is a variant of search with sorting semantics for the results. Returned data contains a space separated list of matching message numbers.
IMAP4.status(mailbox, names)：Request named status conditions for mailbox.
IMAP4.store(message_set, command, flag_list)：Alters flag dispositions for messages in mailbox. command is specified by section 6.4.6 of RFC 2060 as being one of “FLAGS”, “+FLAGS”, or “-FLAGS”, optionally with a suffix of ”.SILENT”.
IMAP4.thread(threading_algorithm, charset, search_criterion[, ...])：The thread command is a variant of search with threading semantics for the results. Returned data contains a space separated list of thread members.
IMAP4.uid(command, arg[, ...])：Execute command args with messages identified by UID, rather than message number. Returns response appropriate to command. At least one argument must be supplied; if none are provided, the server will return an error and an exception will be raised.
IMAP4.unsubscribe(mailbox)：Unsubscribe from old mailbox.
IMAP4.xatom(name[, arg[, ...]])：Allow simple extension commands notified by server in CAPABILITY response.
IMAP4_SSL.ssl()：Returns SSLObject instance used for the secure connection with the server.
IMAP4.PROTOCOL_VERSION：The most recent supported protocol in the CAPABILITY response from the server.
IMAP4.debug：Integer value to control debugging output. The initialize value is taken from the module variable Debug. Values greater than three trace each command.
2、imap 命令详解
CREATE <folder>：CREATE可以创建指定名字的新邮箱。邮箱名称通常是带路径的文件夹全名。（有些IMAP客户机使用邮件夹称呼新邮箱）
C: A003 CREATE owatagusiam/                 /*创建一个新目录owatagusiam*/
S: A003 OK CREATE completed
C: A004 CREATE owatagusiam/blurdybloop  
/* 在创建的目录owatagusiam下创建一个名为blurdybloop 的邮箱，当然可以省略第一步，直接A004 CREATE owatagusiam/blurdybloop ，表示在新的目录owatagusiam 下创建了一个名为blurdybloop 的邮箱*/         
S: A004 OK CREATE completed
DELETE <folder>：DELETE命令删除指定名字的文件夹。文件夹名字通常是带路径的文件夹全名，当邮箱被删除后，其中的邮件也不复存在。
C: A683 DELETE blurdybloop
S: A683 OK DELETE completed 
C: A684 DELETE foo
S: A684 NO Name "foo" has inferior hierarchical names
C: A685 DELETE foo/bar 
S: A685 OK DELETE Completed
RENAME <old folder><new folder>：RENAME命令可以修改文件夹的名称，它使用两个参数：当前邮箱名和新邮箱名，两个参数的命名符合标准路径命名规则。
C: A683 RENAME blurdybloop sarasoop
S: A683 OK RENAME completed
C: A684 RENAME stuff/junk newbox         /*把stuff目录（文件夹）下的邮箱junk改名为newbox*/
S: A684 OK RENAME Completed
LIST <BASE><template>：LIST命令用于列出邮箱中已有的文件夹，有点像操作系统的列目录命令，有两个参数，邮箱路 径参数BASE：表示用户登陆目录；第二个参数template：表示希望显示的邮箱名。这个命令可以包含起始的路径位置和需要列出的文件夹所符合的特 征，可以使用通配符"*"。
C: A101 LIST "" ""
S: * LIST (\Noselect) "/" ""
S: A101 OK LIST Completed
C: A102 LIST #news.comp.mail.misc ""
S: * LIST (\Noselect) "." #news.
S: A102 OK LIST Completed
C: A103 LIST /usr/staff/jones ""
S: * LIST (\Noselect) "/" /
S: A103 OK LIST Completed
C: A202 LIST ~/Mail/ %
S: * LIST (\Noselect) "/" ~/Mail/foo
S: * LIST () "/" ~/Mail/meetings
S: A202 OK LIST completed
APPEND <folder><attributes><date/time><size><mail data>：APPEND命令允许Client上载一个邮件到指定的Folder（文件夹/邮箱）中。命令中包含了新邮件的属性、日期/时间、大 小，随后是邮件数据。
C: A003 APPEND saved-messages (\Seen) {310}
C: Date: Mon， 7 Feb 1994 21:52:25 -0800 (PST)
C: From: Fred Foobar <foobar@Blurdybloop.COM>
C: Subject: afternoon meeting
C: To: mooch@owatagu.siam.edu
C: Message-Id: <B27397-0100000@Blurdybloop.COM>
C: MIME-Version: 1.0
C: Content-Type: TEXT/PLAIN; CHARSET=US-ASCII
C:
C: Hello Joe， do you think we can meet at 3:30 tomorrow?
C:
S: A003 OK APPEND completed
SELECT <folder>：SELECT命令让Client选定某个邮箱（Folder），表示即将对该邮箱（Folder）内的邮件作操作。邮箱标志的当前状态也返回给了用户，同时返回的还有一些关于邮件和邮箱的附加信息。
C: A142 SELECT INBOX
S: * 172 EXISTS
S: * 1 RECENT
S: * OK [UNSEEN 12] Message 12 is first unseen
S: * OK [UIDVALIDITY 3857529045] UIDs valid
S: * FLAGS (\Answered \Flagged \Deleted \Seen \Draft)
S: * OK [PERMANENTFLAGS (\Deleted \Seen \*)] Limited
S: A142 OK [READ-WRITE] SELECT completed
FETCH <mail id><datanames>：FETCH 命令用于读取邮件的文本信息，且仅用于显示的目的。包含两个参数，messageset：表示希望读取的邮件号列表，IAMP服务器邮箱中的每个邮件都有 一个唯一的ID标识，（邮件号列表参数可以是一个邮件号，也可以是由逗号分隔的多个邮件号，或者由冒号间隔的一个范围），IMAP服务器返回邮件号列表中 全部邮件的指定数据项内容。
数据名参数确定能够被独立返回的邮件的一部分，下面我们看看各参数返回的邮件信息：
ALL：只返回按照一定格式的邮件摘要，包括邮件标志、RFC822.SIZE、自身的时间和信封信息。IMAP客户机能够将标准邮件解析成这些信息并显示出来。
BODY：只返回邮件体文本格式和大小的摘要信息。IMAP客户机可以识别这些细腻，并向用户显示详细的关于邮件的信息。其实是一些非扩展的BODYSTRUCTURE的信息。
FAST：只返回邮件的一些摘要，包括邮件标志、RFC822.SIZE、和自身的时间。
FULL：同样的还是一些摘要信息，包括邮件标志、RFC822.SIZE、自身的时间和BODYSTRUCTURE的信息。
BODYSTRUCTUR： 是邮件的[MIME-IMB]的体结构。这是服务器通过解析[RFC-2822]头中的[MIME-IMB]各字段和[MIME-IMB]头信息得出来 的。包括的内容有：邮件正文的类型、字符集、编码方式等和各附件的类型、字符集、编码方式、文件名称等等。
ENVELOPE：信息的信封结构。是服务器通过解析[RFC-2822]头中的[MIME-IMB]各字段得出来的，默认各字段都是需要的。主要包括：自身的时间、附件数、收件人、发件人等。
FLAGS：此邮件的标志。
INTERNALDATE：自身的时间。
RFC822.SIZE：邮件的[RFC-2822]大小
RFC822.HEADER：在功能上等同于BODY.PEEK[HEADER]，
RFC822：功能上等同于BODY[]。
RFC822.TEXT：功能上等同于BODY[TEXT]
UID：返回邮件的UID号，UID号是唯一标识邮件的一个号码。
BODY[section] <<partial>>：返回邮件的中的某一指定部分，返回的部分用section来表示，section部分包含的信息通常是 代表某一部分的一个数字或者是下面的某一个部分：HEADER, HEADER.FIELDS, HEADER.FIELDS.NOT, MIME, and TEXT。如果section部分是空的话，那就代表返回全部的信息，包括头信息。
BODY[HEADER]返回完整的文件头信息。
BODY[HEADER.FIELDS ()]：在小括号里面可以指定返回的特定字段。
BODY[HEADER.FIELDS.NOT ()]：在小括号里面可以指定不需要返回的特定字段。
BODY[MIME]：返回邮件的[MIME-IMB]的头信息，在正常情况下跟BODY[HEADER]没有区别。
BODY[TEXT]：返回整个邮件体，这里的邮件体并不包括邮件头。
STORE <mail id><new attributes>：STORE 命令用于修改指定邮件的属性，包括给邮件打上已读标记、删除标记，等等。STORE命令当前只有两个数据项类型可用，FLAGS：表示邮件的一组标志； FLAGS.SLIENT，表示一组邮件的标志，通过在两种数据项前加上加号或者减号可以进一步改变它们的执行情况，加号表示数据项的值添加到邮件中，减 号表示将数据项的值从邮件中删除。
C: A003 STORE 2:4 +FLAGS (\Deleted)      /*冒号表示间隔的一个范围：给从2到4的邮件设置Deleted属性*/
S: * 2 FETCH FLAGS (\Deleted \Seen)
S: * 3 FETCH FLAGS (\Deleted)
S: * 4 FETCH FLAGS (\Deleted \Flagged \Seen)
S: A003 OK STORE completed
同时改命令还可以用于把邮件标记为未读等等。在web上可以对邮件进行的操作在imap中都可以实现。
CLOSE：CLOSE命令表示Client结束对当前Folder（文件夹/邮箱）的访问，关闭邮箱该邮箱中所有标志为、DELETED的邮件就被从物理上删除。CLOSE没有命令参数。随后可以SELECT另一Folder。
C: A341 CLOSE
S: A341 OK CLOSE completed

EXPUNGE:EXPUNGE命令在不关闭邮箱的情况下删除所有的标志为、DELETED的邮件。EXPUNGE删除的邮件将不可以恢复。 
C: A202 EXPUNGE
S: * 3 EXPUNGE
S: * 3 EXPUNGE
S: * 5 EXPUNGE
S: * 8 EXPUNGE
S: A202 OK EXPUNGE completed
LOGOUT:LOGOUT命令结束本次IMAP会话。
C: A023 LOGOUT
S: * BYE IMAP4rev1 Server logging out
S: A023 OK LOGOUT completed
(Server and client then close the connection)
EXAMINE <mailbox>:
EXAMINE命令以只读方式打开邮箱，参数是需要打开的邮箱的名字，使用EXAMINE命令打开的邮箱不允许对邮件进行改动，因此不能增加或删除邮件的标志。
SUBSCRIBE <mailbox>:SUBSCRIBE命令用来在客户机的活动邮箱列表中增加一个邮箱，该命令只有一个参数，希望添加的邮箱名。
C: A114 SUBSCRIBE new/anotherbox
S: A114 OK SUBSCRIBE completed
UNSUBSCRIBE <mailbox>:UNSUBSCRIBE命令用来从活动列表中去掉一个邮箱，一个参数：希望去掉的邮箱名。
C: A115 UNSUBSCRIBE new/anotherbox
S: A115 OK SUBSCRIBE completed
LSUB <folder><mailbox>:LSUB命令修正了LIST命令，LIST返回用户$HOME目录下所有的文件，但LSUB命令只显示那些使用SUBSCRIBE命令设置为活动邮箱的文件。两个参数：邮箱路径和邮箱名。
C: A116 LSUB “” *
S:* LSUB () “/” stuff/junk
S:* LSUB () “/” neebox
S:* LSUB () “/” new/anotherbox
S: A116 OK LSUB completed
STATUS <mailbox>(<parameter1>  < parameter2>  ……<parameter5>):STATUS命令查询邮箱的当前状态。第一个参数是需要查询的邮箱名，第二个参数是客户机需要查询的项目列 表（要查询显示的信息），当在圆括号中。STATUS可以在不使用SELECT命令（打开邮箱）或者EXAMINE（以只读方式打开邮箱）前提下获取邮箱 的信息。
STATUS命令可以获得的数据项
项 目                 说  明
MESSAGE         邮箱中的邮件总数
RECENT         邮箱中标志为\RECENT的邮件数
UIDNEXT         可以分配给新邮件的下一个UID
UIDVALIDITY         邮箱的UID有效性标志
UNSEEN         邮箱中没有被标志为\UNSEEN的邮件数
C: A117 STATUS inbox  (message recent unseen)
S:* STATUS inbox (MESSAGE 1 RECENT 0 UNSENN 0)
S: A117 OK STATUS completed
C: A118 STATUS newbox  (message recent unseen)
S:* STATUS inbox (MESSAGE 1 RECENT 0 UNSENN 2)
S: A118 OK STATUS completed
CHECK :CHECK命令用来在邮箱设置一个检查点。没有参数。就是IMAP中的sync命令。任何未完成的操作，例如从服务器内存向硬盘写数据，都将会被做完以保持邮箱的一致性状态。该命令确保乃村中的磁盘缓冲数据都被写到了磁盘上。
SEARCH [CHARSET specification] (search criteria):命 令可以根据搜索条件在处于活动状态的邮箱中搜索邮件，然后显示匹配的邮件编号。字符集标志参数[CHARSET specification]由CHARSET和注册的字符集标志符组成，缺省的标志符是US-ASCⅡ，所以该参数长省略。search criteria：查询条件参数，明确查询的关键字和值。查询关键字有几十种。
C: A119 SEARCH header subject another
S: SEARCH 1 2
S:* A119 OK SEARCH completed
C: A120 SEARCH header subject another
S: *SEARCH 2
S: A120 OK SEARCH completed
C: A121 SEARCH UNSEEN
S: *SEARCH 1 2
S: A120 OK SEARCH completed
以上每个例子都在邮件头的Subject:字段中查询一个不同的单词。服务器返回条件的邮件号列表，如果没有匹配邮件则返回不带UID的SEARCH单词。
COPY <mail id><mailboxname>:COPY命令可以把邮件从一个邮箱复制到另一个邮箱，两个参数：mail id是希望从活动邮箱中复制的邮件的标号，mailboxname是希望邮件被复制到的邮箱。
IAMP没有定义移动邮件的命令，移动操作相当于先把邮件复制到新邮箱中，然后对源邮箱中的邮件设置\DELETED标志。下一次执行检查点过后，新邮箱中的邮件被删除，新邮件就被显示出来。
UID:UID 命令和FETCH、COPY、STORE命令或者SEARCH命令一起使用，它允许这些命令使用邮件的UID号而不是在邮箱中的顺序号。UID号是唯一标 识邮件系统中邮件的32位证书。通常这些命令都使用顺序号来标识邮箱中的邮件，使用UID可以使IMAP客户机记住不同IMAP会话中的邮件。
CAPABILITY:CAPABILITY命令请求返回IMAP服务器支持的功能列表，服务器收到客户机发送的CAPABILITY命令后将返回该服务器所支持的功能。无参数。
C: A122 CAPABILITY
S:*A122 CAPABILITY IMAP4 IMAP4REVl NAMESPACE IDLE SCAN SORT   MAILBOX
--REFERRALS [ic:ccc] LOGIN-REFERRALS AUTH=LOGIN THREAD=
ORDERDSUBJECT
S: A122 OK CAPABILITY completed
NOOP:NOOP命令什么也不做，用来向服务器发送自动命令，防止因长时间处于不活动状态而导致连接中断，服务器对该命令的响应始终为肯定。无参数。
LOGOUT:LOGOUT命令使当前登陆用户退出登陆并关闭所有打开的邮箱，任何做了\DELETED标志的邮件都将在这个时候被删除。










SMTP (Simple Mail Transfer Protocol)
　　邮件传送代理 (Mail Transfer Agent，MTA) 程序使用SMTP协议来发送电邮到接收者的邮件服务器。SMTP协议只能用来发送邮件，不能用来接收邮件。大多数的邮件发送服务器 (Outgoing Mail Server) 都是使用SMTP协议。SMTP协议的默认TCP端口号是25。
　　SMTP协议的一个重要特点是它能够接力传送邮件。它工作在两种情况下：一是电子邮件从客户机传输到服务器；二是从某一个服务器传输到另一个服务器。

POP3 (Post Office Protocol) & IMAP (Internet Message Access Protocol)
　　POP协议和IMAP协议是用于邮件接收的最常见的两种协议。几乎所有的邮件客户端和服务器都支持这两种协议。
　　POP3协议为用户提供了一种简单、标准的方式来访问邮箱和获取电邮。使用POP3协议的电邮客户端通常的工作过程是：连接服务器、获取所有信息并保存在用户主机、从服务器删除这些消息然后断开连接。POP3协议的默认TCP端口号是110。
　　IMAP协议也提供了方便的邮件下载服务，让用户能进行离线阅读。使用IMAP协议的电邮客户端通常把信息保留在服务器上直到用户显式删除。这 种特性使得多个客户端可以同时管理一个邮箱。IMAP协议提供了摘要浏览功能，可以让用户在阅读完所有的邮件到达时间、主题、发件人、大小等信息后再决定 是否下载。IMAP协议的默认TCP端口号是143。

邮件格式 (RFC 2822)
　　每封邮件都有两个部分：邮件头和邮件体，两者使用一个空行分隔。
　　邮件头每个字段 (Field) 包括两部分：字段名和字段值，两者使用冒号分隔。有两个字段需要注意：From和Sender字段。From字段指明的是邮件的作者，Sender字段指 明的是邮件的发送者。如果From字段包含多于一个的作者，必须指定Sender字段；如果From字段只有一个作者并且作者和发送者相同，那么不应该再 使用Sender字段，否则From字段和Sender字段应该同时使用。
　　邮件体包含邮件的内容，它的类型由邮件头的Content-Type字段指明。RFC 2822定义的邮件格式中，邮件体只是单纯的ASCII编码的字符序列。
MIME (Multipurpose Internet Mail Extensions) (RFC 1341)
　　MIME扩展邮件的格式，用以支持非ASCII编码的文本、非文本附件以及包含多个部分 (multi-part) 的邮件体等。

Python email模块
1. class email.message.Message
__getitem__，__setitem__实现obj[key]形式的访问。
Msg.attach(playload): 向当前Msg添加playload。
Msg.set_playload(playload): 把整个Msg对象的邮件体设成playload。
Msg.add_header(_name, _value, **_params): 添加邮件头字段。
2. class email.mime.base.MIMEBase(_maintype, _subtype, **_params)
　　所有MIME类的基类，是email.message.Message类的子类。
3. class email.mime.multipart.MIMEMultipart()
　　在3.0版本的email模块 (Python 2.3-Python 2.5) 中，这个类位于email.MIMEMultipart.MIMEMultipart。
　　这个类是MIMEBase的直接子类，用来生成包含多个部分的邮件体的MIME对象。
4. class email.mime.text.MIMEText(_text)
　　使用字符串_text来生成MIME对象的主体文本。

发邮件代码范例：
[python] view plain copy
print?
#!/usr/bin/env python  
# -*- coding: UTF-8 -*-  
   
from email.mime.multipart import MIMEMultipart  
from email.mime.base import MIMEBase  
from email.mime.text import MIMEText  
   
# python 2.3.*: email.Utils email.Encoders  
from email.utils import COMMASPACE,formatdate  
from email import encoders  
   
import os  
   
#server['name'], server['user'], server['passwd']  
def send_mail(server, fro, to, subject, text, files=[]):   
    assert type(server) == dict   
    assert type(to) == list   
    assert type(files) == list   
   
    msg = MIMEMultipart()   
    msg['From'] = fro   
    msg['Subject'] = subject   
    msg['To'] = COMMASPACE.join(to) #COMMASPACE==', '   
    msg['Date'] = formatdate(localtime=True)   
    msg.attach(MIMEText(text))   
   
    for file in files:   
        part = MIMEBase('application', 'octet-stream') #'octet-stream': binary data   
        part.set_payload(open(file, 'rb'.read()))   
        encoders.encode_base64(part)   
        part.add_header('Content-Disposition', 'attachment; filename="%s"' % os.path.basename(file))   
        msg.attach(part)   
   
    import smtplib   
    smtp = smtplib.SMTP(server['name'])   
    smtp.login(server['user'], server['passwd'])   
    smtp.sendmail(fro, to, msg.as_string())   
    smtp.close()  
文件形式的邮件：
[python] view plain copy
print?
#!/usr/bin/env python3    
#coding: utf-8    
  
import smtplib    
from email.mime.text import MIMEText    
from email.header import Header    
    
sender = '***'    
receiver = '***'    
subject = 'python email test'    
smtpserver = 'smtp.163.com'    
username = '***'    
password = '***'    
    
msg = MIMEText('你好','text','utf-8') #中文需参数‘utf-8’，单字节字符不需要    
msg['Subject'] = Header(subject, 'utf-8')    
    
smtp = smtplib.SMTP()    
smtp.connect('smtp.163.com')    
smtp.login(username, password)    
smtp.sendmail(sender, receiver, msg.as_string())    
smtp.quit()   
HTML形式的邮件 
[python] view plain copy
print?
#!/usr/bin/env python3    
#coding: utf-8    
  
import smtplib    
from email.mime.text import MIMEText    
    
sender = '***'    
receiver = '***'    
subject = 'python email test'    
smtpserver = 'smtp.163.com'    
username = '***'    
password = '***'    
    
msg = MIMEText('<html><h1>你好</h1></html>','html','utf-8')    
    
msg['Subject'] = subject    
    
smtp = smtplib.SMTP()    
smtp.connect('smtp.163.com')    
smtp.login(username, password)    
smtp.sendmail(sender, receiver, msg.as_string())    
smtp.quit()    
带图片的HTML形式的邮件
[python] view plain copy
print?
#!/usr/bin/env python3    
#coding: utf-8    
  
import smtplib    
from email.mime.multipart import MIMEMultipart    
from email.mime.text import MIMEText    
from email.mime.image import MIMEImage    
    
sender = '***'    
receiver = '***'    
subject = 'python email test'    
smtpserver = 'smtp.163.com'    
username = '***'    
password = '***'    
    
msgRoot = MIMEMultipart('related')    
msgRoot['Subject'] = 'test message'    
    
msgText = MIMEText('<b>Some <i>HTML</i> text</b> and an image.<br><img src="cid:image1"><br>good!','html','utf-8')    
msgRoot.attach(msgText)    
    
fp = open('h:\\python\\1.jpg', 'rb')    
msgImage = MIMEImage(fp.read())    
fp.close()    
    
msgImage.add_header('Content-ID', '<image1>')    
msgRoot.attach(msgImage)    
    
smtp = smtplib.SMTP()    
smtp.connect('smtp.163.com')    
smtp.login(username, password)    
smtp.sendmail(sender, receiver, msgRoot.as_string())    
smtp.quit()  
带附件的邮件
[python] view plain copy
print?
#!/usr/bin/env python3    
#coding: utf-8    
  
import smtplib    
from email.mime.multipart import MIMEMultipart    
from email.mime.text import MIMEText    
from email.mime.image import MIMEImage    
    
sender = '***'    
receiver = '***'    
subject = 'python email test'    
smtpserver = 'smtp.163.com'    
username = '***'    
password = '***'    
    
msgRoot = MIMEMultipart('related')    
msgRoot['Subject'] = 'test message'    
    
#构造附件    
att = MIMEText(open('h:\\python\\1.jpg', 'rb').read(), 'base64', 'utf-8')    
att["Content-Type"] = 'application/octet-stream'    
att["Content-Disposition"] = 'attachment; filename="1.jpg"'    
msgRoot.attach(att)    
            
smtp = smtplib.SMTP()    
smtp.connect('smtp.163.com')    
smtp.login(username, password)    
smtp.sendmail(sender, receiver, msgRoot.as_string())    
smtp.quit()  
群邮件
[python] view plain copy
print?
#!/usr/bin/env python3    
#coding: utf-8   
   
import smtplib    
from email.mime.text import MIMEText    
    
sender = '***'    
receiver = ['***','****',……]    
subject = 'python email test'    
smtpserver = 'smtp.163.com'    
username = '***'    
password = '***'    
    
msg = MIMEText('你好','text','utf-8')    
    
msg['Subject'] = subject    
    
smtp = smtplib.SMTP()    
smtp.connect('smtp.163.com')    
smtp.login(username, password)    
smtp.sendmail(sender, receiver, msg.as_string())    
smtp.quit()    
各种元素都包含的邮件
[python] view plain copy
print?
#!/usr/bin/env python3    
#coding: utf-8    
  
import smtplib    
from email.mime.multipart import MIMEMultipart    
from email.mime.text import MIMEText    
from email.mime.image import MIMEImage    
    
sender = '***'    
receiver = '***'    
subject = 'python email test'    
smtpserver = 'smtp.163.com'    
username = '***'    
password = '***'    
    
# Create message container - the correct MIME type is multipart/alternative.    
msg = MIMEMultipart('alternative')    
msg['Subject'] = "Link"    
    
# Create the body of the message (a plain-text and an HTML version).    
text = "Hi!\nHow are you?\nHere is the link you wanted:\nhttp://www.python.org"    
html = """\  
<html>  
  <head></head>  
  <body>  
    <p>Hi!<br>  
       How are you?<br>  
       Here is the <a href="http://www.python.org">link</a> you wanted.  
    </p>  
  </body>  
</html>  
"""    
    
# Record the MIME types of both parts - text/plain and text/html.    
part1 = MIMEText(text, 'plain')    
part2 = MIMEText(html, 'html')    
    
# Attach parts into message container.    
# According to RFC 2046, the last part of a multipart message, in this case    
# the HTML message, is best and preferred.    
msg.attach(part1)    
msg.attach(part2)    
#构造附件    
att = MIMEText(open('h:\\python\\1.jpg', 'rb').read(), 'base64', 'utf-8')    
att["Content-Type"] = 'application/octet-stream'    
att["Content-Disposition"] = 'attachment; filename="1.jpg"'    
msg.attach(att)    
       
smtp = smtplib.SMTP()    
smtp.connect('smtp.163.com')    
smtp.login(username, password)    
smtp.sendmail(sender, receiver, msg.as_string())    
smtp.quit()  



python 发送邮件（文字、表格、附件）


import pandas as pd
import smtplib  
from email.mime.text import MIMEText  
from email.mime.multipart import MIMEMultipart

filename='C:\\Users\\thinkpad\\Desktop\\1.xlsx' #附件地址

def send_mail(to_list,sub,context,filename):  #to_list：收件人；sub：主题；content：邮件内容
    mail_host="smtp.163.com"  #设置服务器
    mail_user="XXXX@163.com"    #用户名
    mail_pass="xxxxxx"   #口令 
    mail_postfix="163.com"  #发件箱的后缀
    me="服务器"+"<"+mail_user+"@"+mail_postfix+">"   #这里的“服务器”可以任意设置，收到信后，将按照设置显示
    msg = MIMEMultipart() #给定msg类型
    msg['Subject'] = sub #邮件主题
    msg['From'] = me
    msg['To'] = ";".join(mailto_list) 
    msg.attach(context)
    #构造附件1
    att1 = MIMEText(open(filename, 'rb').read(), 'xls', 'gb2312')
    att1["Content-Type"] = 'application/octet-stream'
    att1["Content-Disposition"] = 'attachment;filename='+filename[-6:]#这里的filename可以任意写，写什么名字，邮件中显示什么名字，filename[-6:]指的是之前附件地址的后6位
    msg.attach(att1)
    try:  
        s = smtplib.SMTP()  
        s.connect(mail_host)  #连接smtp服务器
        s.login(mail_user,mail_pass)  #登陆服务器
        s.sendmail(me, mailto_list, msg.as_string())  #发送邮件
        s.close() 
        return True  
    except Exception:    
        return False  


if __name__ == '__main__':  
    mailto_list=["zhanghaili@autoht.com"]
    a=pd.DataFrame({'数列1':(1,1,1,1),'数列2':(2,2,2,2),'数列3':(3,3,3,3),'数列4':(4,4,4,4)})
    a.index={'行1','行2','行3','行4'} #这里dataframe类型a就是要输出的表格
    sub="test"
    d='' #表格内容
    for i in range(len(a)):
        d=d+"""
        <tr>
          <td>""" + str(a.index[i]) + """</td>
          <td>""" + str(a.iloc[i][0]) + """</td>
          <td width="60" align="center">""" + str(a.iloc[i][1]) + """</td>
          <td width="75">""" + str(a.iloc[i][2]) + """</td>
          <td width="80">""" + str(a.iloc[i][3]) + """</td>
        </tr>"""
    html = """\
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />


<body>
<div id="container">
<p><strong>测试程序邮件发送:</strong></p>
<div id="content">
 <table width="30%" border="2" bordercolor="black" cellspacing="0" cellpadding="0">
<tr>
  <td width="40"><strong>统计</strong></td>
  <td width="50"><strong>数列1</strong></td>
  <td width="60" align="center"><strong>数列2</strong></td>
  <td width="50"><strong>数列3</strong></td>
  <td width="80"><strong>数列4</strong></td>
</tr>"""+d+"""
</table>
</div>
</div>
</div>
</body>
</html>
      """
    context = MIMEText(html,_subtype='html',_charset='utf-8')  #解决乱码
    if send_mail(mailto_list,sub,context,filename):  
        print ("发送成功")  
    else:  

        print( "发送失败")


程序运行成功后：













 python3之模块SMTP协议客户端与email邮件MIME对象

 
1、smtplib模块的常用类与方法

smtplib模块实现邮件的发送功能，模拟一个stmp客户端，通过与smtp服务器交互来实现邮件发送的功能，可以理解成Foxmail的发邮件功能，在使用之前我们需要准备smtp服务器主机地址、邮箱账号以及密码信息。

在python2.3以后python自带smtplib模块，无需额外安装。

class smtplib.SMTP(host="",port=0,local_hostname=None,[timeout,]source_address=None)：

SMTP类定义作为SMTP的构造函数，定义了一个SMTP客户端会话对象，功能是与smtp服务器建立链接，在链接成功后，就可以向服务器发送相关请求，比如登陆、校验、发送、退出等。

    host：参数为远程smtp主机地址;如：smtp.163.com
    port：为链接端口默认为25
    local_hostname：是将本地主机的FQDN(完整域名)发送 HELO/EHLO（标识用户身份）的指令
    timeout：为链接或尝试链接多少秒后超时
    source_address：绑定到具有多个网络接口的计算机中的某个特定源地址上或特定的TCP端口，它需要一个元组（主机，端口）

SMTP类方法：

SMTP.connect(host='localhost',port=0)　：链接到远程SMTP主机的方法，host为远程主机地址，port为远程主机smtp端口，默认为25，也可以直接使用host:port形式来表示：如：SMTP.connect('smtp.163.com','25')

SMTP.login(user,password)：登陆需要认证的SMTP服务器，参数为用户名与密码，如SMTP.login('python@163.com','123')

SMTP.sendmail(from_addr,to_addrs,msg,mail_options=[],rcpt_options=[])：实现邮件的发送功能，参数from_addr为发件人，to_addrs为收件人，msg为邮件内容，如：SMTP.sendmail('python@163.com','demo@qq.com',body)。

SMTP.starttls(keyfile=None,certfile=None)：启用TLS安全传输模式，所有SMTP指令都将加密传输，如使用gmail的smtp服务时需哟啊启动此项才能正常发送邮件。

SMTP.quit()：断开smtp服务器链接

SMTP.set_debuglevel(level)：设置调试输出级别，值为1，2或True，发送调试消息到服务器

SMTP.send_message(msg,from_addr=None,to_addrs=None,mail_options=[],rcpt_options=[])：这是使用有email.message.Message对象表示的消息进行调用的便捷方法使用sendmail()，参数的含义与sendmail()相同，只有msg是一个Message对象；如果from_addr是None或者to_addrs是None，则send_message用从msg头部提取的地址填充那些参数，from设置为发件人自动，TO设置为to_addrs。

实例1实现简单邮件发送：

import smtplib

from smtplib import SMTP
HOST="smtp.163.com"  #定义smtp主机
SUBJECT="test email form python"  #定义邮件主题
TO = "11111@163.com"   #定义邮件收件人
FROM="22222@163.com"  #定义邮件发件人
text="python is test smtp"   #邮件内容,编码为ASCII范围内的字符或字节字符串，所以不能写中文
BODY = '\r\n'.join((      #组合sendmail方法的邮件主体内容，各段以"\r\n"进行分离
    "From: %s" %"admin",
    "TO: %s" %TO,
    "subject: %s" %SUBJECT,
    "",
    text
))
server = SMTP()   #创建一个smtp对象
server.connect(HOST,'25')  #链接smtp主机
server.login(FROM,"123")  #邮箱账号登陆
server.sendmail(FROM,TO,BODY) #发送邮件
server.quit()  #端口smtp链接

实例2：读取文件内容发送邮件主体

import smtplib
from email.utils import formataddr
from email.mime.text import MIMEText

with open('textfile','rb') as fp:   #读取文件内容
    msg=MIMEText(fp.read(),'plain','utf-8')   #创建消息对象


msg['Subject'] = "emailMessage"
msg['From'] = formataddr(["张三","920664709@163.com"])
msg['To'] = formataddr(["李四","920664709@163.com"])

try:
    server = smtplib.SMTP() # 创建一个 SMTP() 对象
    server.connect("smtp.163.com","25") # 通过 connect 方法连接 smtp 主机
    #server.starttls() # 启动安全传输模式
    server.login("920664709@163.com","xxxxxx") # 邮箱账号登录校验
    server.sendmail("92066@163.com","92066@163.com", msg.as_string()) # 邮件发送
    server.quit() # 断开 smtp 连接
    print("邮件发送成功！")
except Exception as e:
    print('失败：'+str(e))

2、处理邮件MIME

通过邮件传输简单的文本已经无法满足我们的需求，比如我们时常会定制业务质量报表，在邮件主体中会包含 HTML、图像、声音以及附件格式等，MIME（Multipurpose Internet Mail Extensions，多用途互联网邮件扩展）作为一种新的扩展邮件格式很好地补充了这一点，更多MIME 知识见 https://docs.python.org/3/library/email.html。下面介绍几个 Python 中常用的 MIME 实现类：

email.mime.base.MIMEBase（_maintype，_subtype，*，policy = compat32，** _ params ）：

这是所有MIME特定类的基类，_maintpe是Content-Type主要类型（text or image），_subtype是Content-Type次要类型（plain or gif），_params是一个键值字典参数直接传递给Message.add_header

filename1 = '图片.pdf'
attachfile_base = MIMEBase('application', 'octet-stream')  #创建基础对象指定类型
attachfile_base.set_payload(open(filename,'rb').read())  #设置我有效负载
attachfile_base.add_header('Content-Disposition', 'attachment', filename=('utf-8', '', filename1) )
encoders.encode_base64(attachfile_base)
msg.attach(attachfile_base)

email.mime.multipart.MIMEMultipart（_subtype='mixed'，boundary= None，_subparts = None，*，policy = compat32，** _ params )：
作用是生成包含多个部分的邮件体的 MIME 对象，参数 _subtype 指定要添加到"Content-type:multipart/subtype" 报头的可选的三种子类型，分别为 mixed、related、alternative，默认值为 mixed。定义 mixed实现构建一个带附件的邮件体；定义related 实现构建内嵌资源的邮件体；定义alternative 则实现构建纯文本与超文本共存的邮件体；_subparts是有效负载的一系类初始部分，可以使用attach()方法将子部件附加到消息中。

from email.mime.multipart import MIMEMultipart

msg1 = MIMEMultipart('mixed')  #创建带附件的实例
msg2 = MIMEMultipart('related')  #创建内嵌资源的实例
msg3 = MIMEMultipart('alternative') #创建纯文本与超文本实例

email.mime.application.MIMEApplication(_data, _subtype='octet-stream', _encoder=email.encoders.encode_base64, *, policy=compat32, **_params)：

被用来表示主要类型的MIME消息对象应用，_data是一个包含原始字节数据的字符串，_subtype指定MIME子类型默认为八位字节流，_encoder是一个可调用函数，它执行传输数据的实际编码，使用set_payload()将有效载荷改为编码形式，默认编码位base64,可使用email.encoders模块查看内置编码表。

filename = '简历.pdf'
with open(filename,'rb') as f:
    attachfile = MIMEApplication(f.read())
attachfile.add_header('Content-Disposition', 'attachment', filename=filename)
msg.attach(attachfile)

email.mime.audio.MIMEAudio (_audiodata[, _subtype[, _encoder]])：

创建包含音频数据的邮件体，_audiodata 包含原始二进制音频数据的字节字符串；_subtype音频类型，_encoder编码。

from email.mime.audio import MIMEAudio

msgaudio = MIMEAudio(open('yishengsuoai.mp3','rb').read(),'plain')   #文本音频对象

msgaudio.add_header('Content-Disposition','attachment',filename='text.mp3') #扩展标题类型，文件名
msg.attach(msgaudio) #附加对象加入到msg

email.mime.image.MIMEImage(_imagedata[, _subtype[, _encoder[, **_params]]])：

MIMENonMultipart中的一个子类,创建包含图片数据的邮件体，_imagedata 是包含原始图片数据的字节字符串；_sutype指定图像子类型；_encoder指定一个函数内部编码默认为：email.encoders.encode_base64默认为base64编码

from email.mime.image import MIMEImage   #导入MIMEImage类

with open('test.png','rb') as fp:
    msgImage = MIMEImage(fp.read()) #读取图片赋值一个图片对象

msgImage.add_header('Content-ID','imgid') #为图片对象拓展标题字段和值
msg.attach(msgImage) #将图像负载添加到msg负载

email.mime.text.MIMEText (_text[, _subtype[, _charset]])：

MIMENonMultipart中的一个子类，创建包含文本数据的邮件体，_text 是包含消息负载的字符串，_subtype 指定文本类型，支持 plain（默认值）或 html类型的字符串。_charset设置字符集，参数接受一个charset实例。

from email.mime.text import MIMEText

#创建文本内容的邮件体
msg = MIMEText("python test email",'plain','utf-8')

#创建HTML格式的邮件体
msg = MIMEText("<p>python test email</p><p><a href="http://www.demo.com">链接</a></p>",'html','utf-8')

MIME实例对象的方法：

    as_string() ：返回字符串信息，相当于__str__(),str(msg)
    as_bytes() ：返回字节信息，相当于__bytes__(),bytes(msg)
    is_multipart() ：判断是否为有效载荷的列表message对象，是返回True,否则返回False
    set_unixfrom(unixfrom) ：将消息的信封头设置为unixfrom为字符串
    get_unixfrom() ：返回消息的信封头。默认为None
    attach(payload) ：将给定的有效负载添加到当前有效负载
    get_payload(i=None, decode=False) ：返回当前的有效载荷，这将是一个列表 Message
    set_payload(payload, charset=None) :将整个消息对象的有效载荷设置为有效载荷
    set_charset(charset) ；将有效负载的字符集设置为charset
    get_charset() :返回Charset与消息有效负载相关的实例
    __len__() :返回标题的总数，包括重复项
    __contains__(name) :如果消息对象具有名为name的字段，则返回true
    __getitem__(name) :返回指定标题字段的值
    __setitem__(name, val) :将字段添加到带有字段名称和值val的消息中
    __delitem__(name) :从消息的标题中删除所有出现的具有名称name的字段
    keys() :返回所有消息标题字段名称的列表
    values() :返回所有消息字段值的列表
    items() ：返回包含所有消息的字段标题和值
    add_header(_name, _value, **_params) :扩展标题设置,_name为要添加的标题字段，_value为标题的值。

msg.add_header('Content-ID','imgid')   #设置图片ID
msg.add_header('Content-Disposition','attachment',filename='test.xlsx') #为附件添加一个标题
msg.add_header('Content-Disposition','attachment',filename=('utf-8','','中文标题')) #添加非ASCII字符时需指定编码

    replace_header(_name,_value) :替换标题

更多内容请阅读官方文档

email.header.Header(s=None,charset=None)：创建一个可以包含不同字符集中的字符串，并符合MIME的标头。

可选参数:s是初始标题值默认为None,可以使用append()方法追加到标题，charset指定字符集

from email.header import Header

msg['From'] = Header("测试邮件来自",'utf-8')

附加工具：email.utils

email.utils.localtime(dt=None)　：返回当前时间，dt参数为datetime实例

email.utils.formataddr(pair,charset='utf-8')　　：pair是一个元祖或列表返回分割的标题和地址如邮箱收件人昵称和邮箱账号

from email.utils import formataddr
msg['From'] = formataddr(['Meslef','92066@163.com'])
msg['To'] = formataddr(['Anybody','92066@163.com'])

 3、实例

前面介绍了 Python 的 smtplib 及 email模块的常用方法，那么两者在邮件定制到发送过程中是如何分工的？我们可以将 email.mime 理解成 smtplib 模块邮件内容主体的扩展，从原先默认只支持纯文本格式扩展到HTML，同时支持附件、音频、图像等格式，smtplib 只负责邮件的投递即可。下面介绍在日常运营工作中邮件应用的几个示例

通过引入email.mime的MIMEText类来实现支持HTML格式的邮件，支持所有HTML元素，包括表格、图片、动画、CSS样式、表单等。
（1）使用HTML的表格定制业务数据报表

#!/usr/bin/env python
# -*- coding: utf-8 -*-
# @Time    : 2018/6/1 11:58
# @Author  : Py.qi
# @File    : fangwenliang.py
# @Software: PyCharm

import smtplib
from email.mime.text import MIMEText # 导入 MIMEText 类

HOST = "smtp.qq.com" # 定义 smtp 主机
SUBJECT = u" 官网流量数据报表 " # 定义邮件主题
TO = "92066@163.com" # 定义邮件收件人
FROM = "92066@qq.com" # 定义邮件发件人
test = """
<body>
<table width="800" border="1" cellspacing="0" cellpadding="4">
<tr>
    <td bgcolor="#CECFAD" height="20" style="font-size:14px">* 官网数据 <a
    href="http://www.baidu.com"> 更多 >></a></td>
</tr>
<tr>
    <td bgcolor="#EFEBDE" height="100" style="font-size:13px">
        1、 日访问量 :<font color=red>152433</font> 
            访问次数 :23651 
            页面浏览量 :45123
            点击数 :545122 
            数据流量 :504Mb<br>
        2、状态码信息 <br>
            &nbsp;&nbsp;500:105 404:3264 503:214<br>
        3、访客浏览器信息 <br>
            &nbsp;&nbsp;IE:50% firefox:10% chrome:30% other:10%<br>
        4、页面信息 <br>
            &nbsp;&nbsp;/index.php 42153<br>
            &nbsp;&nbsp;/view.php 21451<br>
            &nbsp;&nbsp;/login.php 5112<br>
    </td>
</tr>
</table>
"""              
msg = MIMEText(test,"html","utf-8")  #定义主体内容
msg['Subject'] = SUBJECT # 邮件主题
msg['From']=FROM # 邮件发件人 , 邮件头部可见
msg['To']=TO # 邮件收件人 , 邮件头部可见
try:
    server = smtplib.SMTP() # 创建一个 SMTP() 对象
    server.connect(HOST,"25") # 通过 connect 方法连接 smtp 主机
    server.starttls() # 启动安全传输模式
    server.login("92066@qq.com","iqcuwzhgmj") # 邮箱账号登录校验
    server.sendmail(FROM, TO, msg.as_string()) # 邮件发送
    server.quit() # 断开 smtp 连接
    print("邮件发送成功！")
except Exception as e:
    print('失败：'+str(e))

发送带图片的邮件时，需要引入MIMEImage类和MIMEText类组合实现图文格式的数据发送；通过MIMEMultipart类来进行组装
（2）定制服务器性能报表发送邮件

#!/usr/bin/env python
# -*- coding: utf-8 -*-
# @Time    : 2018/6/1 11:58
# @Author  : Py.qi
# @File    : fangwenliang.py
# @Software: PyCharm

import smtplib
from email.mime.text import MIMEText # 导入 MIMEText 类
from email.mime.multipart import MIMEMultipart  #导入MIMEMultipart类
from email.mime.image import MIMEImage   #导入MIMEImage类

HOST = "smtp.qq.com" # 定义 smtp 主机
SUBJECT = u"系统性能报表" # 定义邮件主题
TO = "92066@163.com" # 定义邮件收件人
FROM = "92066@qq.com" # 定义邮件发件人

def addimg(src,imgid):   #定义图片读取函数，参数1为图片路径，2为图片ID机标识符
    with open(src,'rb') as f:
        msgimage = MIMEImage(f.read())   #读取图片内容
    msgimage.add_header('Content-ID',imgid)  #指定文件的Content-ID,<img>,在HTML中图片src将用到
    return msgimage

msg = MIMEMultipart('related')  #创建MIMEMultipart对象，采用related定义内嵌资源邮件体

test = """  
<table width="600" border="0" cellspacing="0" cellpadding="4">
    <tr bgcolor="#CECFAD" height="20" style="font-size:14px">
        <td colspan=2>*系统性能数据 <a href="10.0.0.10"> 更多 >></a></td>
    </tr>
    <tr bgcolor="#EFEBDE" height="100" style="font-size:13px">
        <td>
            <img src="cid:io">   #图片地址由MIMEMultipart通过ID传递
        </td>
        <td>
            <img src="cid:key_hit">
        </td>
    </tr>
    <tr bgcolor="#EFEBDE" height="100" style="font-size:13px">
        <td>
            <img src="cid:men">
        </td>
        <td>
            <img src="cid:swap">
        </td>
    </tr>
</table>
"""
msgtext = MIMEText(test,"html","utf-8") #创建Text对象内容，包括图片<img>

msg.attach(msgtext)   #MIMEMultipart对象附加MIMEText的内容
msg.attach(addimg("1.png",'io'))  #附加图片内容，io指向HTML文本内的参数
msg.attach(addimg("2.png",'key_hit'))
msg.attach(addimg("3.png",'men'))
msg.attach(addimg("4.png",'swap'))

msg['Subject'] = SUBJECT # 邮件主题
msg['From']=FROM # 邮件发件人 , 邮件头部可见
msg['To']=TO # 邮件收件人 , 邮件头部可见
try:
    server = smtplib.SMTP() # 创建一个 SMTP() 对象
    server.connect(HOST,"25") # 通过 connect 方法连接 smtp 主机
    server.starttls() # 启动安全传输模式
    server.login("92066@qq.com","iqcuwzhgmj") # 邮箱账号登录校验
    server.sendmail(FROM, TO, msg.as_string()) # 邮件发送
    server.quit() # 断开 smtp 连接
    print("邮件发送成功！")
except Exception as e:
    print('失败：'+str(e))

（3）带图片及附件的邮件
View Code
（4）所有邮件格式总结

#!/usr/bin/env python
# -*- coding: utf-8 -*-
# @Time    : 2018/6/2 12:06
# @Author  : Py.qi
# @File    : coent_smtp.py
# @Software: PyCharm

import smtplib
from email.utils import make_msgid,formatdate
from email.mime.text import MIMEText #html格式和文本格式邮件
from email.mime.multipart import MIMEMultipart #带多个部分的邮件
from email.mime.image import MIMEImage #带图片格式邮件
from email.mime.audio import MIMEAudio  #音频文件对象
from email.utils import formataddr   #分隔标题与地址
from email.header import Header   #设置标题字符集
from email import encoders  #编码器
from email.mime.application import MIMEApplication  #主要类型的MIME消息对象应用
from email.mime.base import MIMEBase

# 发件人地址，通过控制台创建的发件人地址
username = 'service@gemail.com'
# 发件人密码，通过控制台创建的发件人密码
password = '*****'
# 自定义的回复地址
replyto = '92066@qq.com'
# 收件人地址或是地址列表，支持多个收件人，最多30个
rcptto = ['***', '***']

#构建信件标头结构
msg = MIMEMultipart('alternative')  #创建一个多部分的邮件对象
msg['Subject'] = Header('自定义信件主题', 'utf-8')
msg['From'] = formataddr([Header('自定义发信昵称','utf-8'),username])
msg['To'] = formataddr([Header('自定义收信昵称','utf-8'),rcptto])
msg['Reply-to'] = replyto
msg['Message-id'] = make_msgid() #Message-ID标头
msg['Date'] = formatdate()  #日期


#构建文本邮件内容
msg_text = MIMEText('自定义TEXT纯文本部分','plain','utf-8')
msg.attach(msg_text)
#读取文件创建邮件内容
with open('textfile','rb') as fp:   #读取文件内容
    msg_text=MIMEText(fp.read(),'plain','utf-8')

#构建HTML格式的邮件内容
msg_html = MIMEText("<h1>HTML格式邮件</h1>","html","utf-8")
msg.attach(msg_html)

#构建HTML格式邮件带图片内容
html1 = "<div><img src='cid:imgid'></div>"
msg_html_img = MIMEText(html1,'html','utf-8')
msg.attach(msg_html_img)
with open("imgfile","rb") as f:
    msg_img = MIMEImage(f.read())
msg_img.add_header('Content-ID','imgid') #扩展图片标题
msg.attach(msg_img)

#带附件的邮件MIMEApplication
filename = '简历.pdf'
with open(filename,'rb') as f:
    attachfile = MIMEApplication(f.read())
attachfile.add_header('Content-Disposition', 'attachment', filename=filename)
msg.attach(attachfile)

#带多个附件的邮件MIMEApplication
filenames = ['简历.pdf','副本.pdf']
for tmp in filename:
    with open(tmp,'rb') as f:
        attachfiles = MIMEApplication(f.read())
        attachfiles.add_header('Content-Disposition', 'attachment', filename=tmp)
        msg.attach(attachfiles)

#带附件的邮件MIMEBase
filename1 = '图片.pdf'
attachfile_base = MIMEBase('application', 'octet-stream')  #创建基础对象指定类型
attachfile_base.set_payload(open(filename,'rb').read())  #设置我有效负载
attachfile_base.add_header('Content-Disposition', 'attachment', filename=('utf-8', '', filename1) )
encoders.encode_base64(attachfile_base)
msg.attach(attachfile_base)

#创建音频文件
AUDIO_HTML = '''
    <p>this's audio file</p>
    <audio controls>
    <source src="cid:audioid" type="audio/mpeg">
    </audio>
'''
msg_test1 = MIMEText(AUDIO_HTML,'html','utf-8')
msg_audio = MIMEAudio(open('iphone.mp3','rb').read(),'plain')
msg_audio.add_header('Content-ID','audioid')
msg.attach(msg_test1)
msg.attach(msg_audio)
#收到邮件不能播放，有待解决！

# 发送邮件
try:
    client = smtplib.SMTP()
    #需要使用SSL，可以这样创建client
    #client = smtplib.SMTP_SSL()
    client.connect('smtp.163.com', 25)
    #开启DEBUG模式
    client.set_debuglevel(1)
    client.login(username, password)
    client.sendmail(username, rcptto, msg.as_string())
    client.quit()
    print('email send success!')
except smtplib.SMTPConnectError as e:
    print('邮件发送失败，连接失败:', e.smtp_code, e.smtp_error)
except smtplib.SMTPAuthenticationError as e:
    print('邮件发送失败，认证错误:', e.smtp_code, e.smtp_error)
except smtplib.SMTPSenderRefused as e:
    print('邮件发送失败，发件人被拒绝:', e.smtp_code, e.smtp_error)
except smtplib.SMTPRecipientsRefused as e:
    print('邮件发送失败，收件人被拒绝:', e.smtp_code, e.smtp_error)
except smtplib.SMTPDataError as e:
    print('邮件发送失败，数据接收拒绝:', e.smtp_code, e.smtp_error)
except smtplib.SMTPException as e:
    print('邮件发送失败, ', e.message)
except Exception as e:
    print('邮件发送异常, ', str(e))

